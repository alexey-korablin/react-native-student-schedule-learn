# Компонент "Расписание"
На данном занятии мы создадим свой компонент для отображения расписания занятий. После, мы применим к нему стили, что бы он красиво выглядел.

Мы уже создали заготовки файлов для данного компонента. Откройте в редакторе кода путь `src/components/schedule` в проекте. Там вы увидите 3 файла:
- `index.js` - здесь будет хранится основной компонент
- `day-schedule.js` - здесь мы создадим компонент, который будет строить отображение для расписания каждого дня
- `lesson.js` - здесь мы создадим компонент, который будет строить отображение для каждого занятия

Для описания компонентов мы использовали более короткий вид объявления функции - `arrow function`. Я бы советовал так и продолжать использовать, но если вам хочется, вы всегда можете использовать обычные, именованные функции.

```javascript
// оба примера эквивалентны
const test = () => true; // arrow function

function test() { // классическая функция
    return true;
}
```

## Немного теории
Для правильного построения приложения в библиотеке `React Native` есть несколько уже готовых компонентов и объектов.

### Text
Самый простой компонент. Он создан для отображения текста. Другие компоненты не могут отображать текст, пока они не будут использовать данный компонент.
```jsx
<Text>Привет, мир!</Text>
```

### View
Компонент `View` служит для того, что бы организовывать компоненты внутри себя. Он может, например, расположить компоненты по вертикали или горизонтали, или отцетрировать их.
```jsx
<View>
    <Text>Элемент 1</Text>
    <Text>Элемент 2</Text>
    <Text>Элемент 3</Text>
</View>
```

### ScrollView
Это расширение компонента `View`, который помимо организации компонентов умеет еще и прокручиваться при соответствующем движении пальцем.

### StyleSheet
`StyleSheet` не является компонентом. На самом деле это обычный `JavaScript` объект, в котором находятся функции-помощники.
На нашем занятии нас будет интересовать лишь 2 его функции.

#### create
Данная функция помощник создает группированные стили, что бы можно было их использовать в компоненте. Помимо создания группировки, она еще оптимизирует использование стилей: если использовать `StyleSheet.create`, то у вас приложение будет работать быстрее, чем если не использовать (зависит от приложения, конечно же).
```jsx
const styles = StyleSheet.create({
    wrapper: {
        height: 50,
        backgroundColor: 'white',
    },
    text: {
        fontSize: 24,
    }
});

const Component = () => <View style={ styles.wrapper }><Text style={ styles.text }>text</Text></View>;
```

#### flatten
Данная функция помощник позволяет использовать несколько групп стилей на одном компоненте.
```jsx
const styles = StyleSheet.create({
    wrapper: {
        height: 50,
        backgroundColor: 'white',
    },
    hightlighted: {
        backgroundColor: 'yellow',
    }
});

const Component = () => (
    <View style={ StyleSheet.flatten([styles.wrapper, styles.hightlighted]) }>
        <Text>text</Text>
    </View>
);
```

## Создание компонента "Lesson"
> Откройте файл `src/components/schedule/lesson.js`

Сначала мы создадим компонент для отображения одного занятия. Для этого нам понадобится знать название предмета, номера аудиторий (их же может быть 2) и порядковый номер. Все эти данные мы будем получать через `props`. Что бы в функциональном компоненте получить эти `props` нужно задать первый входной аргумент. Добавьте его. Лучше всего будет так этот аргумент и назвать - `props`.

Должно получиться примерно так:
```jsx
const Lesson = (props) => null;
```

Теперь необходимо добавить "контейнеры" для наших данных. "Контейнер" - это компонент `View`, как написано выше. Нужно создать общий "контейнер" и внутри него еще 3. А теперь заполним их. В первом контейнере мы покажем порядковый номер занятия. Для этого в первый вложенный контейнер мы впишем компонент `Text`, внутри которого будет значение `props.index`.

Должно получиться примерно так:
```jsx
<View><Text>{ props.index }</Text></View>
```
Здесь мы окружили переменную `props.index` фигурными скобками. Это необходимо для `JSX`, что бы понимать, что это не статичный текст, а переменная.

Аналогично сделайте для второго контейнера, только там нужно будет указать название предмета из переменной `props.name`.

Третий контейнер содержит номера аудитории. Так как аудиторий может быть несколько, нам нужно, что бы каждая из них была в отдельном компоненте `Text`. Для нам подойдет массив со списком аудиторий. Но из-за ограничений `JSX` мы не можем внутри написать цикл `for`.

Нам надо сделать следующее:
1. В конце файла создать функцию `renderRooms`, которая будет принимать один аргумент - массив с аудиториями. Возращать эта функция будет новый массив, элемента которого будут вида `<Text>{ room }</Text>`.
2. В компоненте, в 3м контейнере вставить вызов этой функции с параметром `props.rooms`. Не забудьте обернуть в фигурные скобки, а то это будет восприниматься как текст.
Пример:
```jsx
<View>{ renderRooms(props.rooms) }</View>
```

Ну вот, компонент `Lesson` готов!

## Создание компонента "DaySchedule"
> Откройте файл `src/components/schedule/day-schedule.js`

Данный компонент будет строить отображение расписания за день. Для этого нам нужно будет показать дату и список занятий.

Для начала создадим контейнер с 2 вложенными контейнерами и во 2м контейнере покажем все наши занятия. Здесь мы можем воспользоваться функцией, как в компоненте `Lesson`. В отличие от компонента `Lesson`, здесь мы будем возвращать массив из наших компонетов `Lesson`. Что бы передать в этот компонент нужные ему `props` мы можем их указать аналогично аттрибутам тэга в `HTML`. Вторым аргументом у этой функции будет `props.isHighlighted` - функция, которая показывает, нужно ли выделить данное занятие цветом или нет. Про это выделение будет позже, когда будем стилизовать наши кампоненты.

Тоесть, примерно так:
```jsx
<Lesson index={ index } name={ props.lesson.name } rooms={ props.lesson.room } key={ index } highlight={ props.isHighlighted(props.lesson) } />
```
> Обратите внимание на атрибут `key`. Этот атрибут необходим для `React`, что бы использовать внутреннюю оптимизацию списков компонентов. Здесь нам будет достаточно передать ему значение `index`

А теперь используем эту функцию в нужном контейнере и список занятий готов!

Далее нам необходимо сделать заголовок дня. Для этого мы там покажем день недели, число месяца и месяц.

Данные по дате у нас ноходятся в переменной `date`. Мы уже создали функции для показа даты в нужном формате - `formatDate`. Эта функция возвращает строку с датой, вам нужно лишь применить ее в нужном месте.

## Создание компонента "Schedule"
> Откройте файл `src/components/schedule/index.js`

Данный компонент будет показыавть все дневные расписания, а так же он будет прокручиваться при "свайпе".

В данном компоненте мы будем использовать `ScrollView` вместо `View`. По сути это одно и тоже, только `ScrollView` умеет прокручиваться вверх/вниз при свайпах. Внутри данного компонента мы будем показывать расписание за неделю.

Мы уже подготовили для вас массив `days` со всеми днями недели, их осталось правильно использовать. Этот массив состоит из объектов вида:
- `date` - объект даты дня
- `schedule` - расписание за указанный день
- `isHighlighted` - функция, которая указывает, нужно ли подсвечивать занятие

Создайте функцию `renderWeek`, которая будет принимать как аргумент массив `days`, а возвращать уже массив с компонентами `DaySchedule` и используйте эту функцию внутри компонента `ScrollView`.

Все компоненты готовы! Вот только выглядит это все очень плохо...

## Стилизация компонентов
Работающее приложение это хорошо, но если оно не красивои не удобно, то все старания впустую. В данной части нашего воркшопа мы будем "разукрашивать" наши компоненты и "ставить на место" элементы.

### Стилизация компонента Schedule
> Откройте файл `src/components/schedule/index.js`

Для начала нам нужно создать описание стилей. Для этого в конце файла создайте переменную `styles`. Эта переменная и будет хранить стили.

Далее нам нужно присвоить этой переменной результат функции `StyleSheet.create`. Передайте в эту функцию пустой объект. В этом пустом объекте создадим свойство `wrapper`, которое будет хранить стили для нашего компонента `ScrollView`. Значением будет объект, у которого будет одно свойство `padding`. Это свойство указывает, что контент внутри компонента должен отстоять от границ компонента на 5 пикселей с каждой стороны.

Должно получиться примерно вот так:
```JavaScript
const styles = StyleSheet.create({
    wrapper: {
        padding: 5,
    },
});
```

Теперь нужно применить созданный стиль на наш компонент. Для этого у компонента `ScrollView` создайте атрибут `style` и присвойте ему значение `styles.wrapper`.
```jsx
<ScrollView style={ styles.wrapper } >...</ScrollView>
```
Можете посмотреть, отступ появился.

Сейчас для данного компонента хватит стилей. В последствии вы сможете сами задать ему стили, например, цвет фона - `backgroundColor`.

### Стилизация компонента DaySchedule
> Откройте файл `src/components/schedule/day-schedule.js`

Здесь, как и у компонента `Schedule`, создайте переменную `styles`. Свойство `padding` можете оставить таким же, а можете изменить. Примените стили `styles.wrapper` на самый внешний компонент `View`.

Добавьте к стилям `wrapper` еще одно - `elevation` со значением 2. Это очень интересное свойство, оно создает эффект "приподнятости" элемента над другими. Хотя если вы сейчас посмотрите на свое приложение, то не увидите разницы. Это все потому, что свойство `elevation` не работает у элементов с прозрачным фоном. Для того, что бы установить фон элемента, к его стилям нужно добавить свойство `backgroundColor` со значением, например, `'white'`.
```JavaScript
const styles = StyleSheet.create({
    wrapper: {
        padding: 5,
        elevation: 2,
        backgroundColor: 'white',
    },
});
```

Теперь опишем стили для "заголовка дня" - даты. Для этого у переменной `styles` создайте новое свойство `header`, внутри которого укажите 2 свойства:
- `fontSize` - размер шрифта. Я бы советовал указать значение `24`
- `fontWeight` - толщина шрифта. Значение `'bold'`

А теперь примените эти стили на компоненте `Text`.

Теперь было бы неплохо как то отодвинуть наши занятия от заголовка. Создадим новое свойство в `styles` с именем `lessonsWrapper`. Там у нас будут стили для 2го вложенного `View`. В этих стилях укажите `padding: 5` и `paddingLeft: 20` и примените эти стили на нужном компоненте.

Свойство `padding` создает отступ с 4 сторон (верх, них, право, лево), а `paddingLeft` задает только слева. Этими 2 свойствами мы сделали отступ слева в 20 пикселей, а сверху, снизу и справа - в 5 пикселей. Этим у нас получился эффект вложенности.

Теперь остался лишь один компонент для стилизации, но он самый сложный.

### Стилизация компонента Lesson
> Откройте файл `src/components/schedule/lesson.js`

Компонент `View` очень близок по отображению к `FlexBox` (`display: flex`) в `CSS`, только он изначально отрисовывется как колонка, а не как строка. именно из-за этой особенности у нас все "поехало". Но сейчас мы все исправим.

Создайте переменную `styles`, аналогично выше.

#### Wrapper
Создайте стили для нашего самого верхнего компонента `View` и сразу примените их на нем.

- Добавьте свойство `flexDirection` со значением `'row'`. Так мы укажем, что бы все элементы внутри были "в строчку"
- Добавьте свойство `flexWrap` со значением `'nowrap'`. Этим мы укажем, что элементы внутри не должны переноситься на новую строку, если не влезут.
- Добавьте свойство `justifyContent` со значением `'flex-start'`. Это свойство укажет, что все элементы должны прижиматься друг к другу и начинаться с начала блока. Другими словами, это свойство указывает распределение элементов по оси направление контейнера
- Добавьте свойство `alignItems` со значением `'stretch'`. Так мы укажем, что бы все элементы внутри должны вытянуться по высоте, что бы занимать всю высоту контейнера. Другими словами, это свойство указывает распределение элементов по оси, перпендикулярной оси направление контейнера

Вот теперь выглядит уже нормально, хотя еще и не совсем красиво. Здесь еще можно добавить слабо заметную границу, что бы было легче следить глазами по строчке. Для этого добавьте свойство `borderBottomWidth` со значением `1`. Это создаст нижнее подчеркивание с толщиной в 1 пиксель. Вот только граница черная, а мы хотели слабо заметную... С помощью свойства `borderColor` можно указать цвет этой границы. Можно использовать значение `'#eee'`, например.

#### Highlight
Вот мы и дошли до стиля `highlight`. Этот стиль будет изменять фон занятия, выделяя его от остальных. Создайте такой стиль у укажите у него свойство `backgroundColor` со значением `'#FAFAD2'`. Теперь осталось лишь его применить.

Для того, что бы объединить стили существует функция `StyleSheet.flatten`. Она принимает единственный аргумент - массив стилей. Используя эту функцию, объедините стили `wrapper` и `highlight` для верхнего компонента `View`.
```jsx
<View style={ StyleSheet.fatten([ styles.wrapper, styles.highlight ]) } >...</View>
```

Теперь у нас занятия подсвечиваются, правда все. Нам нужно добавить условие на применение этого стиля `highlight`. Для этого мы можем использовать тернарное выражение.
`highlight ? styles.highlight : null`.

#### Остальные элементы
Создайте сразу 3 стиля: `index`, `name` и `rooms`. Каждый из этих стилей будет применятся к соответсвующим `View`. Примените эти стили.

У каждого стиля укажите свойство `flexDirection: 'row'` и `alignItems: 'center'`. Таким образом мы все отцентрировали по высоте.

У стилей `index` и `rooms` укажите ширину в 50 и 80 пикселей соответсвенно. За ширину отвечает свойство `width`. Так же у этих стилей укажите свойство `justifyContent` со значение `'center'`.

И остался маленький штрих. Сейчас все элементы прижаты к левому краю, но нам нужно что бы аудитории были с правого края. Для этого есть свойство `flex`. Это свойство указывает, как должен растягивать/сжиматься элемент, чтобы заполнить пространство. По умолчанию `flex` имеет значение 0, что означает, что элемент не тянется/не сжимается. Установите это свойство в `1`, и тогда все встанет на свои места.

Вот и все, мы закончили со стилями. Если хотите, можете с ними "поиграться". ☺
